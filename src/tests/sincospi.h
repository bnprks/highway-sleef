//  Adapted from boost/math/special_functions/sin_pi.hpp and
//  boost/math/special_functions/cos_pi.hpp
//  
//  Copyright (c) 2007 John Maddock
//  Use, modification and distribution are subject to the
//  Boost Software License, Version 1.0. (See text below)

// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef SINCOSPI_H
#define SINCOSPI_H

#define PI 3.141592653589793238462643383279502884L

template <typename T>
static T sinpi(T x) {
  if (x < 0) return -sinpi(-x);
  if (x < 0.5) return std::sin(PI * x);
  bool invert = x < 1;
  if (x < 1) x = -x;

  T rem = std::floor(x);
  if (std::abs(std::floor(rem / 2) * 2 - rem) >
      std::numeric_limits<T>::epsilon()) {
    invert = !invert;
  }
  rem = x - rem;
  if (rem > 0.5) rem = 1 - rem;
  if (rem == 0.5) return invert ? -1 : 1;
  T result = std::sin(PI * rem);
  return invert ? -result : result;
}

template <typename T>
static T cospi(T x) {
  bool invert = false;
  if (std::abs(x) < 0.25) return std::cos(PI * x);
  x = std::abs(x);
  T rem = std::floor(x);
  if (std::abs(std::floor(rem / 2) * 2 - rem) >
      std::numeric_limits<T>::epsilon()) {
    invert = !invert;
  }
  rem = x - rem;
  if (rem > 0.5) {
    rem = 1 - rem;
    invert = !invert;
  }
  if (rem == 0.5) {
    return 0;
  }
  if (rem > 0.25) {
    rem = 0.5 - rem;
    rem = std::sin(PI * rem);
  } else {
    rem = std::cos(PI * rem);
  }
  return invert ? -rem : rem;
}
#undef PI

#endif